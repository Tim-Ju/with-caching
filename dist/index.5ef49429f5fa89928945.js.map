{"version":3,"file":"index.5ef49429f5fa89928945.js","mappings":"mBAKO,I,m2CCFP,wBAEE,KAAAA,OAAiC,CAAC,CA6FpC,CA1FE,YAAAC,IAAA,SAAIC,EAAaC,GACfC,KAAKJ,OAAOE,GAAOC,CACrB,EAGA,YAAAE,IAAA,SAAIH,GACF,OAAOE,KAAKJ,OAAOE,EACrB,EAGA,YAAAI,OAAA,SAAOJ,UACEE,KAAKJ,OAAOE,EACrB,EAEM,YAAAK,UAAN,SAAmBC,EAAsBC,G,qBAAyBC,SAAO,W,wEAUvE,OARER,EAKEO,EAAO,IAJT,EAIEA,EAAO,UAJTE,OAAS,IAAG,MAAG,EAEf,EAEEF,EAAO,eAFTG,OAAc,IAAG,wBAAqB,EACtC,EACEH,EAAO,eADTI,OAAc,IAAG,sBAAmB,EAIjCX,GCzBgB,SAACY,GACxB,MFFiC,mBAAX,QAAf,EAAAC,OADuBA,EEIZD,QFHT,EAAFC,EAAIC,mBAAW,eAAEC,OEIR,iBAANH,GAAqC,mBAAZA,aAAC,EAADA,EAAGI,MFLT,IAACH,E,CEOhC,CDoBiBI,CAAUX,GE5BJ,SAACY,EAAeC,GACrC,IAAMC,EAAcC,KAAKC,MAGzB,OACEJ,GACAA,EAAMjB,OACNmB,EAAcF,EAAMK,WAAaJ,GAXZ,MAazB,CF0BQK,CAHEN,EAAQhB,KAAKC,IAAIH,GAGJS,IAEM,wBAAnBC,GACFR,KAAKuB,wBAAwBnB,EAASN,GAEjC,CAAP,EAAOkB,EAAMjB,QALX,MANK,CAAP,EAAOK,K,cAcCK,G,IACD,gC,IAQA,gC,mBANQ,SAAML,K,OAKjB,OALMoB,EAAK,SACXxB,KAAKH,IAAIC,EAAK,CACZuB,UAAWF,KAAKC,MAChBrB,MAAOyB,IAEF,CAAP,EAAOA,G,OAIP,OAAIR,GACFhB,KAAKuB,wBAAwBnB,EAASN,GAC/B,CAAP,EAAOkB,EAAMjB,QAEN,CAAP,EAAOC,KAAKyB,wBAAwBrB,EAASN,I,yBAOvD,YAAAyB,wBAAA,SAA2BnB,EAAsBN,GAAjD,WACE4B,YAAW,gD,wDAEI,O,sBAAA,GAAMtB,K,cAAXoB,EAAK,SACXxB,KAAKH,IAAIC,EAAK,CACZuB,UAAWF,KAAKC,MAChBrB,MAAOyB,I,aAGT,M,mCAGN,EAEM,YAAAC,wBAAN,SAAiCrB,EAAsBN,G,gGACjD0B,EAAK,K,iBAEF,O,sBAAA,GAAMpB,K,cAAXoB,EAAK,SACLxB,KAAKH,IAAIC,EAAK,CACZuB,UAAWF,KAAKC,MAChBrB,MAAOyB,I,aAGT,M,gBAGF,MAAO,CAAP,EAAOA,G,OAEX,CA/FA,E","sources":["webpack://with-request-cache/./src/utils/isAsyncFunction.ts","webpack://with-request-cache/./src/index.ts","webpack://with-request-cache/./src/utils/isPromise.ts","webpack://with-request-cache/./src/utils/isValid.ts"],"sourcesContent":["/**\n * 判断参数是否为异步函数\n * @param fn\n * @returns\n */\nexport const isAsyncFunction = (fn: any) => {\n  return fn?.constructor?.name === \"AsyncFunction\";\n};\n","import { isPromise } from \"./utils/isPromise\";\nimport { isValid } from \"./utils/isValid\";\n\nexport class RequestCache {\n  /* memory cache records */\n  caches: Record<string, ICache> = {};\n\n  /** set cache */\n  set(key: string, value: ICache): void {\n    this.caches[key] = value;\n  }\n\n  /** get cache */\n  get(key: string): ICache {\n    return this.caches[key];\n  }\n\n  /** remove cache */\n  remove(key: string): void {\n    delete this.caches[key];\n  }\n\n  async withCache<T>(fetcher: TFetcher<T>, options: TCacheOptions): Promise<T> {\n    const {\n      key,\n      validTime = 300, // Default cache time: 300 seconds\n      //cacheType = \"memory\", // Default cache type: memory\n      updateStrategy = \"update-after-return\", // Default update strategy: update-after-return\n      returnStrategy = \"return-when-exist\", // Default return strategy: return-when-exist\n    } = options;\n\n    /** If no key is passed in, it means do not use the cache, directly return the request. */\n    if (!key || !isPromise(fetcher)) {\n      return fetcher();\n    }\n\n    const cache = this.get(key);\n\n    /** if cache is available, return the cache directly */\n    if (isValid(cache, validTime)) {\n      /** update cache after return cache */\n      if (updateStrategy === \"update-after-return\") {\n        this.updateCacheAfterRequest(fetcher, key);\n      }\n      return cache.value;\n    } else {\n      /** If cache is invalid,  */\n      switch (returnStrategy) {\n        case \"return-when-valid\":\n          /** To ensure a valid cache, return the result of the request */\n          const re = await fetcher();\n          this.set(key, {\n            createdAt: Date.now(),\n            value: re,\n          });\n          return re;\n        case \"return-when-exist\": {\n          /** To ensure quick return of data, return the existing cache first, even if it has expired. */\n\n          if (cache) {\n            this.updateCacheAfterRequest(fetcher, key);\n            return cache.value;\n          } else {\n            return this.returnCacheAfterRequest(fetcher, key);\n          }\n        }\n      }\n    }\n  }\n\n  updateCacheAfterRequest<T>(fetcher: TFetcher<T>, key: string) {\n    setTimeout(async () => {\n      try {\n        const re = await fetcher();\n        this.set(key, {\n          createdAt: Date.now(),\n          value: re,\n        });\n      } catch (e) {\n        throw e;\n      }\n    });\n  }\n\n  async returnCacheAfterRequest<T>(fetcher: TFetcher<T>, key: string) {\n    let re = null;\n    try {\n      re = await fetcher();\n      this.set(key, {\n        createdAt: Date.now(),\n        value: re,\n      });\n    } catch (e) {\n      throw e;\n    }\n\n    return re;\n  }\n}\n","import { isAsyncFunction } from \"./isAsyncFunction\";\n\n/**\n * 检查函数的返回值是否为 Promise\n * @param p\n * @returns\n */\nexport const isPromise = (p: any) => {\n  return (\n    isAsyncFunction(p) ||\n    (typeof p === \"object\" && typeof p?.then === \"function\")\n  );\n};\n","const MAX_EXPIRED_TIME = 26 * 60 * 60;\n/**\n * 判断缓存是否可用\n */\nexport const isValid = (cache: ICache, maxAge: number) => {\n  const currentTime = Date.now();\n\n  //可用条件：缓存存在、缓存hash与当前文件hash一致、缓存时间未超过最大缓存时间\n  return (\n    cache &&\n    cache.value &&\n    currentTime - cache.createdAt < (maxAge || MAX_EXPIRED_TIME)\n  );\n};\n"],"names":["caches","set","key","value","this","get","remove","withCache","fetcher","options","Promise","validTime","updateStrategy","returnStrategy","p","fn","constructor","name","then","isPromise","cache","maxAge","currentTime","Date","now","createdAt","isValid","updateCacheAfterRequest","re","returnCacheAfterRequest","setTimeout"],"sourceRoot":""}